class EntityAttack : ZilchComponent
{
    var Attacking : Boolean = false; //whether or not entity is currently attacking
    
    var Cooldown : Real = 0; //how long until the entity stops being in the attacking state, INTERNAL COUNTER, NOT STARTING VALUE
    
    var Windup : Real = 0; //how long of a delay before the attack starts, INTERNAL COUNTER, NOT STARTING VALUE
    
    var Aim : Real3; //attack direction
    
    var BaseCooldown : Real = 0.2; //cooldown value on beginning attack
    
    var BaseWindup :Real = 0.1; //windup value on beginning attack
    
    var Damage : Integer = 1;
    
    var StaggerTimer : Real = 0;
    
    [Property]
    var Knockback : Real = 5;
    
    [Property]
    var Friendly : Boolean; //true if it's a friendly, false if it's an enemy attack
    
    [Property]
    var MinRange : Real = 1; //how many units away the attack tracer is spawned
    
    var AttackCollision : MultiConvexMesh = MultiConvexMesh.KATracer1_1; //the collider used for attacks
    function Initialize(init : CogInitializer)
    {
        Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
    }

    function OnLogicUpdate(event : UpdateEvent)
    {
        if(this.StaggerTimer > 0)
        {
            this.StaggerTimer -= event.Dt;
        }
        if(this.Attacking)
        {
            if(this.Windup > 0)
            {
                this.Windup -= event.Dt;
                if(this.Windup < 0)
                {
                    //var tracer = this.Space.CreateAtPosition(Archetype.AttackTracer, this.Owner.Transform.Translation + this.Aim);
                    //var tracer = this.Space.CreateAtPosition(Archetype.AttackTracer, this.Owner.Transform.Translation + this.Aim * this.MinRange);
                    var tracer = this.Space.CreateAtPosition(Archetype.AttackTracer, Real3(0,1,0) * this.MinRange);
                    //tracer.Transform.Rotation = this.Owner.Transform.Rotation;
                    tracer.AttackTracerBehavior.Damage = this.Damage;
                    tracer.AttackTracerBehavior.Knockback = this.Knockback * this.Aim;
                    //tracer.RigidBody.Velocity = this.Owner.RigidBody.Velocity;
                    tracer.AttachTo(this.Owner);
                    if(this.Friendly)
                    {
                        tracer.Collider.CollisionGroup = CollisionGroup.FriendlyProjectile;
                    } else {
                        tracer.Collider.CollisionGroup = CollisionGroup.EnemyProjectile;
                    }
                    tracer.MultiConvexMeshCollider.Mesh = this.AttackCollision;
                }
            } else {
                this.Cooldown -= event.Dt;
                if(this.Cooldown < 0)
                {
                    this.Attacking = false;
                    
                    //tells playercontrol that an action is finished if that's part of the entity:
                    if(this.Owner.PlayerControl != null)
                    {
                        this.Owner.PlayerControl.ActionFinishedFlag = true;
                    }
                }
            }
        }
    }
    
    function Attack(aim : Real3)
    {
        //only functions if not currently staggered:
        if(this.StaggerTimer <= 0)
        {
            this.Attacking = true;
            this.Cooldown = this.BaseCooldown;
            this.Windup = this.BaseWindup;
            this.Aim = aim;
        }
        
    }
}
