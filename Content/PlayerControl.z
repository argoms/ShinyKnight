/*
PlayerControl
@James/Argoms
    
    Player-specific control script
*/
class PlayerControl : ZilchComponent
{

    var MouseWasDown : Boolean = false; //used to check if the player is clicking or holding mouse down
    
    //internal for movement calculations:
    var LastMovement : Real3; //last movement vector of the player
    var FollowMouse : Boolean = false; //whether or not the player looks at the cursor
    
    //var Attacking : Boolean = false; //whether or not the player is currently attacking
    //DEPRECATED: attacking state now found in EntityAttack behavior
    
    var Weapon : EntityAttack; //contains info for doing damage
    
    var PlayerAnimation : SimpleAnimation; //player's animation
    var PlayerAnimationGraph : AnimationGraph; //player animation graph
    
    var StringProgress : Integer = 1; //how many hits the player is into their String
    var StringCooldown : Real = 0; //time before String resets
    
    //animations:
    [Property]
    var WalkAnimation : Animation;
    [Property]
    var IdleAnimation  : Animation;
    [Property]
    var BlockAnimation : Animation;
    
    
    [Property]
    var Attack1_1Animation : Animation;
    [Property]
    var Attack1_2Animation : Animation;
    [Property]
    var Attack1_3Animation : Animation;
    
    [Property]
    var Attack2_1Animation : Animation;
    [Property]
    var Attack2_2Animation : Animation;
    [Property]
    var Attack2_3Animation : Animation;
    
    
    function Initialize(init : CogInitializer)
    {
        Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
        
        //set up player's camera
        var camera = this.Space.Create(Archetype.PlayerCamera);
        camera.PlayerCameraControl.MySprite = this.Owner.FindChildByName("Sprite");
        camera.PlayerCameraControl.MyPlayer = this.Owner;
        this.LevelSettings.CameraViewport.Camera = camera;
        
        //set up player's attacking:
        this.Weapon = this.Owner.EntityAttack;
        this.Weapon.Friendly = true;
        this.PlayerAnimation = this.Owner.FindChildByName("Mesh").FindChildByName("Mesh").SimpleAnimation;
        this.PlayerAnimationGraph = this.Owner.FindChildByName("Mesh").FindChildByName("Mesh").AnimationGraph;
    }

    function OnLogicUpdate(event : UpdateEvent)
    {
        //update mouse state:
        this.UpdateMouseInput();
        
        //update player translation:
        if(!this.Weapon.Attacking)
        {
            if(Zero.Mouse.IsButtonDown(MouseButtons.Left))
            {
                this.AltAttack();
            } else {
                
                this.PlayerAnimationGraph.TimeScale = 1;
                
                //blocking:
                if(Zero.Mouse.IsButtonDown(MouseButtons.Right))
                {
                    //animation:
                    this.PlayerAnimation.PlaySingle(this.BlockAnimation, AnimPlayMode.Loop);
                    this.PlayerAnimation.Animation = this.BlockAnimation;
                    
                    //internal:
                    this.Owner.EntityHealth.Blocking = true;
                    this.UpdateOrientation(event.Dt, false);
                    
                } else {
                    //regular movement:
                    this.Owner.EntityHealth.Blocking = false;
                    this.UpdateOrientation(event.Dt, true);
                    
                }
                
                //string counter reset:
                this.StringCooldown -= event.Dt;
                if(this.StringCooldown <= 0)
                {
                    this.StringProgress = 1;
                    this.StringCooldown = 0.1;
                }
            }
        } else {
            
        }
    }
    
    /*
    UpdateOrientation
        handles the direction that the player is facing in
        changemovement determienes whether or not the player can actually move
    */
    function UpdateOrientation(dt : Real, changeMovement : Boolean)
    {
        if(changeMovement)
        {
            if(Zero.Mouse.RawMovement != Real2(0,0))
            {
                this.FollowMouse = true;
                if(this.Owner.AutoOrientToVelocity != null)
                {
                    this.Owner.RemoveComponentByName("AutoOrientToVelocity");
                }
            }
            if(this.UpdateMovement(dt))
            {
                
                this.FollowMouse =false;
                //Console.WriteLine("potato");
                if(this.Owner.AutoOrientToVelocity == null)
                {
                    
                    this.Owner.AddComponentByName("AutoOrientToVelocity");
                }
            } 
            if(this.FollowMouse)
            {
                this.AimAtMouse();
                //Console.WriteLine(this.Owner.Orientation.WorldForward);
            }
        } else {
            this.AimAtMouse();
        }
    }
    
    /*
    UpdateMouseInput
        handles mouse press/release function calls
    */
    function UpdateMouseInput()
    {
        
        if(!this.MouseWasDown)
        {
            if(Zero.Mouse.IsButtonDown(MouseButtons.Left))
            {
                this.OnMousePressed();
                this.MouseWasDown = true;
            }
        } else {
            if(!Zero.Mouse.IsButtonDown(MouseButtons.Left))
            {
                this.OnMouseReleased();
                this.MouseWasDown = false;
            }
        }
    }
    
    /*AimAtMouse
        Points player towards mouse
        returns direction
    */
    function AimAtMouse() : Real3
    {
        var cursor:Real2 = Zero.Mouse.ScreenPosition;
        var worldCursor:Real3 = this.LevelSettings.CameraViewport.ScreenToWorldZPlane(cursor, 0);
        var aim:Real3 = Math.Normalize(Real3(worldCursor.X-this.Owner.Transform.Translation.X, worldCursor.Y-this.Owner.Transform.Translation.Y, 0));
        this.Owner.Orientation.LookAtDirectionWithUp(aim, Real3(0,0,1));
        return aim;
    }
    /*
    UpdateMovement
        calculates movement vector based on key input, applies to EntityMovement
        returns whether or not this is the moment where the object just started moving
    */
    function UpdateMovement(dt : Real) : Boolean
    {
        var movement:Real3 = Real3(0, 0, 0); //gets movement direction
        if(Zero.Keyboard.KeyIsDown(Keys.A))
        {
            movement += Real3 (-1, 0, 0);
        }
        if(Zero.Keyboard.KeyIsDown(Keys.D))
        {
            movement += Real3 (1, 0, 0);
        }
        if(Zero.Keyboard.KeyIsDown(Keys.W))
        {
            movement += Real3 (0, 1, 0);
        }
        if(Zero.Keyboard.KeyIsDown(Keys.S))
        {
            movement += Real3 (0, -1, 0);
        }
        Math.Normalize(movement);
        this.Owner.EntityMovement.Move(movement, dt);
        
        var wasJustStill : Boolean = this.LastMovement == Real3(0,0,0);
        this.LastMovement = movement;
        
        //change to walking animation if appropriate:
        if(this.PlayerAnimation.Animation != this.WalkAnimation && movement != Real3(0,0,0))
        {
            
            //this.PlayerAnimation.PlaySingle(Animation.KnightWalk, AnimPlayMode.Loop);
            this.PlayerAnimation.Animation = this.WalkAnimation;
            this.PlayerAnimation.PlaySingle(this.WalkAnimation, AnimPlayMode.Loop);
            this.PlayerAnimation.PlayMode = AnimPlayMode.Loop;
        } else {
            //idle stance if not moving
            if(movement == Real3(0,0,0))
            {
                this.PlayerAnimation.Animation = this.IdleAnimation;
            }
        }
        //this.PlayerAnimation.Animation = Animation.KnightIdle;
        
        return movement != Real3(0,0,0) && wasJustStill;// && this.MovementStopTest != Real3(0,0,0);
        
    }
    
    /*
    Attack
        Tells the player's weapon component to attack
    */
    function Attack()
    {
        
        var aim : Real3= this.AimAtMouse();
        
        this.PlayerAnimation.Animation = null;
        if(this.StringProgress == 1)
        {
            //forward step:
            this.Owner.RigidBody.ApplyLinearVelocity(aim*5);
            this.Weapon.Damage = 1;
            
            //configure weapon:
            this.Weapon.BaseCooldown = 0.1;
            this.Weapon.BaseWindup = 0.1;
            this.Weapon.AttackCollision = MultiConvexMesh.KATracer1_1;
            this.Weapon.Knockback = 5;
            
            //animation play:
            this.PlayerAnimation.PlaySingle(this.Attack1_1Animation, AnimPlayMode.PlayOnce);
            this.PlayerAnimationGraph.TimeScale = 1.25;
        } else if(this.StringProgress == 2)
        {
            //forward step:
            this.Owner.RigidBody.ApplyLinearVelocity(aim*5);
            
            //configure weapon:
            this.Weapon.BaseCooldown = 0.1;
            this.Weapon.BaseWindup = 0.1;
            this.Weapon.AttackCollision = MultiConvexMesh.KATracer1_2;
            this.Weapon.Damage = 1;
            this.Weapon.Knockback = 5;
            
            //animation play:
            this.PlayerAnimation.PlaySingle(this.Attack1_2Animation, AnimPlayMode.PlayOnce);
            this.PlayerAnimationGraph.TimeScale = 1.25;
        } else if(this.StringProgress == 3)
        {
            //forward step:
            this.Owner.RigidBody.ApplyLinearVelocity(aim*20);
            
            //configure weapon:
            this.Weapon.BaseCooldown = 0.4;
            this.Weapon.BaseWindup = 0.1;
            this.Weapon.AttackCollision = MultiConvexMesh.KATracer1_3;
            this.Weapon.Damage = 2;
            this.Weapon.Knockback = 25;
            
            //animation play:
            this.PlayerAnimation.PlaySingle(this.Attack1_3Animation, AnimPlayMode.PlayOnce);
            this.PlayerAnimationGraph.TimeScale = 1;
        }
        
        this.Weapon.Attack(aim);
        
        this.StringProgress += 1;
        if(this.StringProgress > 3)
        {
            this.StringProgress = 1;
        }
        //this.PlayerAnimation.PlayMode = AnimPlayMode.PlayOnce;
    }
    
    /*
    AltAttack
        Player's alternate attack combo
    */
    function AltAttack()
    {
        var aim : Real3= this.AimAtMouse();
        
        this.PlayerAnimation.Animation = null;
        if(this.StringProgress == 1)
        {
            //forward step:
            this.Owner.RigidBody.ApplyLinearVelocity(aim*5);
            this.Weapon.Damage = 1;
            
            //configure weapon:
            this.Weapon.BaseCooldown = 0.1;
            this.Weapon.BaseWindup = 0.1;
            this.Weapon.AttackCollision = MultiConvexMesh.KATracer2_1;
            this.Weapon.Knockback = 5;
            
            //animation play:
            this.PlayerAnimation.PlaySingle(this.Attack2_1Animation, AnimPlayMode.PlayOnce);
            this.PlayerAnimationGraph.TimeScale = 1.25;
        } else if(this.StringProgress == 2)
        {
            //forward step:
            this.Owner.RigidBody.ApplyLinearVelocity(aim*3);
            
            //configure weapon:
            this.Weapon.BaseCooldown = 0.1;
            this.Weapon.BaseWindup = 0.1;
            this.Weapon.AttackCollision = MultiConvexMesh.KATracer2_2;
            this.Weapon.Damage = 1;
            this.Weapon.Knockback = 5;
            
            //animation play:
            this.PlayerAnimation.PlaySingle(this.Attack2_2Animation, AnimPlayMode.PlayOnce);
            this.PlayerAnimationGraph.TimeScale = 1;
        } else if(this.StringProgress == 3)
        {
            //forward step:
            this.Owner.RigidBody.ApplyLinearVelocity(aim*50);
            
            //configure weapon:
            this.Weapon.BaseCooldown = 0.4;
            this.Weapon.BaseWindup = 0.1;
            this.Weapon.AttackCollision = MultiConvexMesh.KATracer2_3;
            this.Weapon.Damage = 2;
            this.Weapon.Knockback = 25;
            
            //animation play:
            this.PlayerAnimation.PlaySingle(this.Attack2_3Animation, AnimPlayMode.PlayOnce);
            this.PlayerAnimationGraph.TimeScale = 2;
        }
        
        this.Weapon.Attack(aim);
        
        this.StringProgress += 1;
        if(this.StringProgress > 3)
        {
            this.StringProgress = 1;
        }
        //this.PlayerAnimation.PlayMode = AnimPlayMode.PlayOnce;
    }
    
    function OnMousePressed()
    {
        if(!this.Weapon.Attacking)
        {
            if(this.Owner.EntityHealth.Blocking)
            {
                this.AltAttack();
            } else {
                this.Attack();
            }
        }
    }
    
    function OnMouseReleased()
    {
    }
}
