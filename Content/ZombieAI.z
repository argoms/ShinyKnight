/*
ZombieAI

AI for zombie-like opponents (eg. standard lollipop men)
*/

class ZombieAI : ZilchComponent
{
    var TargetEntity: Cog;
    var MovementVector:Real3;
    var Attacking : Boolean = false;
    [Property]
    var AttackRange : Real = 4;
    
    [Property]
    var WalkAnimation : Animation;
    
    [Property]
    var AttackAnimation : Animation;
    
    [Property]
    var IdleAnimation : Animation;
    
    [Property]
    var PresetTarget : CogPath;
    
    var Weapon : EntityAttack;
    
    [Property]
    var Mesh:CogPath;
    
    [Property]
    var PreAttackPause : Real = 0.5;
    
    var AttackPauseTimer : Real = 0;
    
    [Property]
    var AttackTracer : MultiConvexMesh;
    
    [Property]
    var LungeStrength : Real = 10;
    
    var EntityAnimation : SimpleAnimation;
    var EntityAnimationGraph : AnimationGraph;
    
    var JustAttacking : Boolean = false;
    
    var StringCounter : Integer = 1;
    var StringCoolDown : Real = 0;
    function Initialize(init : CogInitializer)
    {
        Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
        if(this.PresetTarget != null)
        {
            this.TargetEntity = this.PresetTarget.Cog;
        }
        this.Weapon = this.Owner.EntityAttack;
        this.Weapon.AttackCollision = this.AttackTracer;
        this.Weapon.BaseWindup = 0.15;
        this.Weapon.BaseCooldown = 1;
        this.Weapon.MinRange = 0.5;
        this.Weapon.Damage = 5;
    
        
        this.EntityAnimation = this.Mesh.Cog.SimpleAnimation;
        this.EntityAnimationGraph = this.Mesh.Cog.AnimationGraph;
        this.EntityAnimationGraph.TimeScale = 1;
        
    }

    function OnLogicUpdate(event : UpdateEvent)
    {
        if(this.StringCoolDown > 0)
        {
            this.StringCoolDown -= event.Dt;
            if(this.StringCoolDown <= 0)
            {
                this.StringCounter = 1;
            }
        }
        if(this.Owner.EntityAttack.StaggerTimer > 0)
        {
            this.AttackPauseTimer = -1;
            this.JustAttacking = true;
        }
        
        if(this.AttackPauseTimer <= 0)
        {
            
            if(!this.Weapon.Attacking)
            {
                
                this.MovementVector =  this.TargetEntity.Transform.Translation - this.Owner.Transform.Translation;
                
                
                
                //play walk anim if attack just finished:
                if(this.JustAttacking)
                {
                   // this.EntityAnimationGraph.TimeScale = 1;
                    var endAnim = this.EntityAnimationGraph.CreateBasicNode(this.WalkAnimation, AnimPlayMode.Loop);
                    endAnim.CollapseToPoseOnFinish = true;
                    
                    var blend = this.EntityAnimationGraph.CreateCrossBlendNode();
                    blend.From = this.EntityAnimationGraph.ActiveNode;
                    blend.To = endAnim;
                    blend.CollapseToPoseOnFinish = true;
                    blend.Duration = 0.25;
                    
                    this.EntityAnimationGraph.ActiveNode = blend;
                    
                    
                    //this.EntityAnimation.DirectBlend(this.WalkAnimation, 0.25, AnimPlayMode.PlayOnce);
                    //this.EntityAnimation.PlaySingle(this.WalkAnimation, AnimPlayMode.Loop);
                }
                
                if(this.DistanceSQ(this.MovementVector) <= this.AttackRange && this.StringCounter < 2)
                {
                    this.MovementVector = (this.AimAtTarget());
                    //this.Owner.RemoveComponentByName("AutoOrientToVelocity");
                    this.AttackPauseTimer = this.PreAttackPause;
                    
                    //create animation:
                    
                    var endAnim = this.EntityAnimationGraph.CreateBasicNode(this.AttackAnimation, AnimPlayMode.PlayOnce);
                    endAnim.CollapseToPoseOnFinish = true;
                    
                    var blend = this.EntityAnimationGraph.CreateDirectBlendNode();
                    blend.From = this.EntityAnimationGraph.ActiveNode;
                    blend.To = endAnim;
                    blend.Duration = this.PreAttackPause;
                    blend.CollapseToPoseOnFinish = true;
                    this.EntityAnimationGraph.ActiveNode = blend;
                    
                    //deprecated:
                    //this.EntityAnimation.DirectBlend(this.AttackAnimation, this.PreAttackPause, AnimPlayMode.PlayOnce);
                    
                } else {
                    Math.Normalize(this.MovementVector);
                    this.Owner.EntityMovement.Move(this.MovementVector, event.Dt);
                    if(this.Owner.AutoOrientToVelocity == null)
                    {
                        this.Owner.Orientation.LookAtDirection(this.MovementVector);
                        //this.Owner.AddComponentByName("AutoOrientToVelocity");
                    }
                }
                
            }
            
            this.JustAttacking = this.Weapon.Attacking;
        } else {
            this.AttackPauseTimer -= event.Dt;
            
            if(this.AttackPauseTimer <= 0 && this.AttackPauseTimer > -1)
            {
                
                this.Owner.EntityDelayedStep.AddStep(0.1, this.MovementVector*this.LungeStrength);
                this.StringCounter += 1;
                this.StringCoolDown = 0.5;
                Math.Normalize(this.MovementVector);
                this.Weapon.Attack(this.MovementVector);
            }
        }
    }
    
    /*
    DistanceSQ
    
        Returns the square of the 2D size of a real3
    */
    function DistanceSQ(input : Real3): Real
    {
        return input.X * input.X + input.Y * input.Y;
    }
    
    function AimAtTarget() : Real3
    {
        var targetLocation:Real3 = this.PresetTarget.Cog.Transform.Translation;
        var aim:Real3 = Math.Normalize(Real3(targetLocation.X-this.Owner.Transform.Translation.X, targetLocation.Y-this.Owner.Transform.Translation.Y, 0));
        this.Owner.Orientation.LookAtDirectionWithUp(aim, Real3(0,0,1));
        return aim;
    }
}
