/*
ZombieAI

AI for zombie-like opponents (eg. standard lollipop men)
*/

class ZombieAI : ZilchComponent
{
    var TargetEntity: Cog;
    var MovementVector:Real3;
    var Attacking : Boolean = false;
    [Property]
    var AttackRange : Real = 4;
    
    [Property]
    var WalkAnimation : Animation;
    
    [Property]
    var AttackAnimation : Animation;
    
    [Property]
    var IdleAnimation : Animation;
    
    [Property]
    var PresetTarget : CogPath;
    
    var Weapon : EntityAttack;
    
    [Property]
    var Mesh:CogPath;
    
    [Property]
    var PreAttackPause : Real = 0.5;
    
    var AttackPauseTimer : Real = 0;
    
    [Property]
    var AttackTracer : MultiConvexMesh;
    
    [Property]
    var LungeStrength : Real = 10;
    
    var EntityAnimation : SimpleAnimation;
    var EntityAnimationGraph : AnimationGraph;
    
    var JustAttacking : Boolean = false;
    function Initialize(init : CogInitializer)
    {
        Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
        if(this.PresetTarget != null)
        {
            this.TargetEntity = this.PresetTarget.Cog;
        }
        this.Weapon = this.Owner.EntityAttack;
        this.Weapon.AttackCollision = this.AttackTracer;
        this.Weapon.BaseWindup = 0.15;
        this.Weapon.BaseCooldown = 1;
        this.Weapon.MinRange = 0.5;
        this.Weapon.Damage = 5;
    
        
        this.EntityAnimation = this.Mesh.Cog.SimpleAnimation;
        this.EntityAnimationGraph = this.Mesh.Cog.AnimationGraph;
        this.EntityAnimationGraph.TimeScale = 1;
        
    }

    function OnLogicUpdate(event : UpdateEvent)
    {
        if(this.Owner.EntityAttack.StaggerTimer > 0)
        {
            this.AttackPauseTimer = -1;
            this.JustAttacking = true;
        }
        
        if(this.AttackPauseTimer <= 0)
        {
            if(!this.Weapon.Attacking)
            {
                
                this.MovementVector =  this.TargetEntity.Transform.Translation - this.Owner.Transform.Translation;
                if(this.DistanceSQ(this.MovementVector) <= this.AttackRange)
                {
                    this.MovementVector = (this.AimAtTarget());
                    this.Owner.RemoveComponentByName("AutoOrientToVelocity");
                    this.AttackPauseTimer = this.PreAttackPause;
                    this.EntityAnimation.DirectBlend(this.AttackAnimation, this.PreAttackPause, AnimPlayMode.PlayOnce);
                    //this.EntityAnimation.PlaySingle(this.IdleAnimation, AnimPlayMode.PlayOnce);
                    //this.Attacking = true;
                    //Console.WriteLine(this.DistanceSQ(this.MovementVector));
                } else {
                    Math.Normalize(this.MovementVector);
                    this.Owner.EntityMovement.Move(this.MovementVector, event.Dt);
                    if(this.Owner.AutoOrientToVelocity == null)
                    {
                        this.Owner.AddComponentByName("AutoOrientToVelocity");
                    }
                }
                
                
                //play walk anim if attack just finished:
                if(this.JustAttacking)
                {
                    this.EntityAnimationGraph.TimeScale = 1;
                    this.EntityAnimation.PlaySingle(this.WalkAnimation, AnimPlayMode.Loop);
                }
            } else {
                
            }
            this.JustAttacking = this.Weapon.Attacking;
        } else {
            this.AttackPauseTimer -= event.Dt;
            if(this.AttackPauseTimer <= 0 && this.AttackPauseTimer > -1)
            {
                
                this.Owner.RigidBody.ApplyLinearVelocity(this.MovementVector * this.LungeStrength);
                Math.Normalize(this.MovementVector);
                this.Weapon.Attack(this.MovementVector);
                this.EntityAnimationGraph.TimeScale = 1;
                this.EntityAnimation.PlaySingle(this.AttackAnimation, AnimPlayMode.PlayOnce);
            }
        }
    }
    
    /*
    DistanceSQ
    
        Returns the square of the 2D size of a real3
    */
    function DistanceSQ(input : Real3): Real
    {
        return input.X * input.X + input.Y * input.Y;
    }
    
    function AimAtTarget() : Real3
    {
        var targetLocation:Real3 = this.PresetTarget.Cog.Transform.Translation;
        var aim:Real3 = Math.Normalize(Real3(targetLocation.X-this.Owner.Transform.Translation.X, targetLocation.Y-this.Owner.Transform.Translation.Y, 0));
        this.Owner.Orientation.LookAtDirectionWithUp(aim, Real3(0,0,1));
        return aim;
    }
}
