/*
ZombieAI

AI for zombie-like opponents (eg. standard lollipop men)
*/

class ZombieAI : ZilchComponent
{
    var TargetEntity: Cog;
    var MovementVector:Real3;
    var Attacking : Boolean = false;
    [Property]
    var AttackRange : Real = 4;
    
    [Property]
    var WalkAnimation : Animation;
    
    [Property]
    var AttackAnimation : Animation;
    
    [Property]
    var IdleAnimation : Animation;
    
    [Property]
    var PresetTarget : CogPath;
    
    var Weapon : EntityAttack;
    
    [Property]
    var Mesh:CogPath;
    
    [Property]
    var PreAttackPause : Real = 0.5;
    
    var AttackPauseTimer : Real = 0;
    
    [Property]
    var AttackTracer : MultiConvexMesh;
    
    [Property]
    var LungeStrength : Real = 10;
    
    [Property]
    var AggroZone : CogPath;
    
    var EntityAnimation : SimpleAnimation;
    var EntityAnimationGraph : AnimationGraph;
    
    var JustAttacking : Boolean = false;
    
    var StringCounter : Integer = 1;
    var StringCoolDown : Real = 0;
    
    var TargetAcquiredFlag : Boolean = false;
    function Initialize(init : CogInitializer)
    {
        Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
        if(this.PresetTarget != null)
        {
            this.TargetEntity = this.PresetTarget.Cog;
        }
        this.Weapon = this.Owner.EntityAttack;
        this.Weapon.AttackCollision = this.AttackTracer;
        this.Weapon.BaseWindup = 0.3;
        this.Weapon.BaseCooldown = 1;
        this.Weapon.MinRange = 0.5;
        this.Weapon.Damage = 5;
    
        
        this.EntityAnimation = this.Mesh.Cog.SimpleAnimation;
        this.EntityAnimationGraph = this.Mesh.Cog.AnimationGraph;
        this.EntityAnimationGraph.TimeScale = 1;
        
    }

    function OnLogicUpdate(event : UpdateEvent)
    {
        //gets the enemy walking if they were just idle:
        if(!this.TargetAcquiredFlag && this.TargetEntity != null)
        {
            this.PlayWalkAnimation();
        }
    
        if(this.TargetEntity != null)
        {
            //string cooldown management, doesn't do much with existing enemies but might as well keep the functionality for future use
            if(this.StringCoolDown > 0)
            {
                this.StringCoolDown -= event.Dt;
                if(this.StringCoolDown <= 0)
                {
                    this.StringCounter = 1;
                }
            }
            
            //do nothing if staggered:
            if(this.Owner.EntityAttack.StaggerTimer > 0)
            {
                this.AttackPauseTimer = -1;
                this.JustAttacking = true;
            }
            
            if(this.AttackPauseTimer <= 0)
            {
                
                if(!this.Weapon.Attacking)
                {
                    
                    this.MovementVector =  this.TargetEntity.Transform.Translation - this.Owner.Transform.Translation;
                    
                    //play walk anim if attack just finished:
                    if(this.JustAttacking)
                    {
                       // this.EntityAnimationGraph.TimeScale = 1;
                        this.PlayWalkAnimation();
                    }
                    
                    //if within range, begin to attack
                    if(this.DistanceSQ(this.MovementVector) <= this.AttackRange && this.StringCounter < 2)
                    {
                        this.Windup();
                        
                    } else {
                        //otherwise, fake autoorienttovelocity in a way that doesn't do weird things when knocked back
                        Math.Normalize(this.MovementVector);
                        this.Owner.EntityMovement.Move(this.MovementVector, event.Dt);
                        this.Owner.Orientation.LookAtDirection(this.MovementVector);
                    }
                    
                }
                
                this.JustAttacking = this.Weapon.Attacking;
            } else {
                this.AttackPauseTimer -= event.Dt;
                
                //once windup is finished, actually attack:
                if(this.AttackPauseTimer <= 0 && this.AttackPauseTimer > -1)
                {
                    this.Attack();
                }
            }
            
        } else {
            //do idle things if there's no enemy
            this.BeIdle();
        }
        
        //flag setting to check for transitions:
        this.TargetAcquiredFlag = (this.TargetEntity != null);
        this.TargetEntity = this.AggroZone.Cog.EnemyAggroZone.Target;
        
    }
    
    function BeIdle()
    {
        var endAnim = this.EntityAnimationGraph.CreateBasicNode(this.IdleAnimation, AnimPlayMode.PlayOnce);
        endAnim.CollapseToPoseOnFinish = true;
        
        var blend = this.EntityAnimationGraph.CreateDirectBlendNode();
        blend.From = this.EntityAnimationGraph.ActiveNode;
        blend.To = endAnim;
        blend.Duration = this.PreAttackPause;
        blend.CollapseToPoseOnFinish = false;
        this.EntityAnimationGraph.ActiveNode = blend;
    }
    
    function Attack()
    {
        this.Owner.EntityDelayedStep.AddStep(0.1, this.MovementVector*this.LungeStrength);
        this.StringCounter += 1;
        this.StringCoolDown = 0.5;
        Math.Normalize(this.MovementVector);
        this.Weapon.Attack(this.MovementVector);
    }
    
    /*pre-attack windup*/
    function Windup()
    {
        this.MovementVector = (this.AimAtTarget());
        //this.Owner.RemoveComponentByName("AutoOrientToVelocity");
        this.AttackPauseTimer = this.PreAttackPause;
        
        //create animation:
        
        var endAnim = this.EntityAnimationGraph.CreateBasicNode(this.AttackAnimation, AnimPlayMode.PlayOnce);
        endAnim.CollapseToPoseOnFinish = true;
        
        var blend = this.EntityAnimationGraph.CreateDirectBlendNode();
        blend.From = this.EntityAnimationGraph.ActiveNode;
        blend.To = endAnim;
        blend.Duration = this.PreAttackPause;
        blend.CollapseToPoseOnFinish = true;
        this.EntityAnimationGraph.ActiveNode = blend;
    }
    
    function PlayWalkAnimation()
    {
        var endAnim = this.EntityAnimationGraph.CreateBasicNode(this.WalkAnimation, AnimPlayMode.Loop);
        endAnim.CollapseToPoseOnFinish = true;
        
        var blend = this.EntityAnimationGraph.CreateCrossBlendNode();
        blend.From = this.EntityAnimationGraph.ActiveNode;
        blend.To = endAnim;
        blend.CollapseToPoseOnFinish = true;
        blend.Duration = 0.25;
        
        this.EntityAnimationGraph.ActiveNode = blend;
    }
    
    /*
    DistanceSQ
    
        Returns the square of the 2D size of a real3
    */
    function DistanceSQ(input : Real3): Real
    {
        return input.X * input.X + input.Y * input.Y;
    }
    
    function AimAtTarget() : Real3
    {
        var targetLocation:Real3 = this.TargetEntity.Transform.Translation;//this.PresetTarget.Cog.Transform.Translation;
        var aim:Real3 = Math.Normalize(Real3(targetLocation.X-this.Owner.Transform.Translation.X, targetLocation.Y-this.Owner.Transform.Translation.Y, 0));
        this.Owner.Orientation.LookAtDirectionWithUp(aim, Real3(0,0,1));
        return aim;
    }
}
